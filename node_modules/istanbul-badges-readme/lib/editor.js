"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.editReadme = exports.writeNewReadme = exports.getNewReadme = exports.getCoverageBadge = exports.getCoverageColor = exports.getReadmeHashes = void 0;
const fs_1 = __importDefault(require("fs"));
const arguments_1 = require("./arguments");
const constants_1 = require("./constants");
const helpers_1 = require("./helpers");
const logger_1 = require("./logger");
const { logInfo } = logger_1.logger();
const getReadmeHashes = (readmeFile) => {
    logInfo('- Getting readme hashes...');
    const readmeHashes = constants_1.hashesConst.coverage.map((hash) => {
        if (readmeFile.includes(`![${hash.value}]`)) {
            return hash;
        }
        return false;
    });
    const filteredHashes = readmeHashes.filter(Boolean);
    return filteredHashes;
};
exports.getReadmeHashes = getReadmeHashes;
const getCoverageColor = (coverage) => {
    if (coverage < 80) {
        return 'red';
    }
    if (coverage < 90) {
        return 'yellow';
    }
    return 'brightgreen';
};
exports.getCoverageColor = getCoverageColor;
const getCoverageBadge = (coverageFile, hashKey) => {
    logInfo(`- Getting coverage badge url for ${hashKey}...`);
    try {
        const parsedCoverage = JSON.parse(coverageFile);
        if (!parsedCoverage.total || !parsedCoverage.total[hashKey]) {
            return false;
        }
        const coverage = parsedCoverage.total[hashKey].pct;
        const color = exports.getCoverageColor(coverage);
        const customLabel = arguments_1.getArgumentValue(`${hashKey}Label`);
        const badgeAlt = customLabel ? encodeURI(customLabel) : hashKey;
        return constants_1.coverageUrlConst(badgeAlt, coverage, color);
    }
    catch (_a) {
        return false;
    }
};
exports.getCoverageBadge = getCoverageBadge;
const getNewReadme = (readmeFile, coverageFile) => (readmeHashes) => {
    logInfo('- Getting new readme data...');
    let newReadmeFile = readmeFile;
    return new Promise((resolve, reject) => {
        readmeHashes.forEach((hash) => {
            const coverageBadge = exports.getCoverageBadge(coverageFile, hash.key);
            if (!coverageBadge) {
                reject('There has been an error getting new coverage badges');
            }
            const pattern = `![${hash.value}]`;
            const enpatterned = (value) => `${pattern}(${value})`;
            const startIndex = newReadmeFile.indexOf(pattern);
            const valueToChangeStart = newReadmeFile.slice(startIndex + pattern.length);
            const valueToChangeIndex = valueToChangeStart.indexOf(')');
            const valueToChangeFinal = valueToChangeStart.substring(1, valueToChangeIndex);
            newReadmeFile = newReadmeFile.replace(enpatterned(valueToChangeFinal), enpatterned(coverageBadge));
        });
        resolve(newReadmeFile);
    });
};
exports.getNewReadme = getNewReadme;
const writeNewReadme = (readmePath) => (newReadmeData) => {
    logInfo('- Writing new readme data...');
    try {
        return fs_1.default.writeFileSync(readmePath, newReadmeData, 'utf8');
    }
    catch (_a) {
        return false;
    }
};
exports.writeNewReadme = writeNewReadme;
const editReadme = async () => {
    logInfo('Info: 2. Editor process started');
    const readmeFile = await helpers_1.readFileAsync(helpers_1.getReadmePath(constants_1.readmePathConst), 'utf-8');
    const coverageFile = await helpers_1.readFileAsync(helpers_1.getCoveragePath(constants_1.coveragePathConst), 'utf8');
    return Promise.resolve(exports.getReadmeHashes(readmeFile))
        .then(exports.getNewReadme(readmeFile, coverageFile))
        .then(exports.writeNewReadme(helpers_1.getReadmePath(constants_1.readmePathConst)))
        .then(() => logInfo('Info: 2. Editor process ended'));
};
exports.editReadme = editReadme;
